{"version":3,"file":"TermFunctionRegex.js","sourceRoot":"","sources":["TermFunctionRegex.ts"],"names":[],"mappings":";;;AAAA,yEAAkE;AAIlE,qFAM8C;AAE9C;;GAEG;AACH,MAAa,iBAAkB,SAAQ,uCAAgB;IACrD;QACE,KAAK,CAAC;YACJ,KAAK,EAAE,CAAE,CAAC,EAAE,CAAC,CAAE;YACf,QAAQ,EAAE,2CAAc,CAAC,KAAK;YAC9B,SAAS,EAAE,IAAA,oCAAO,EAAC,2CAAc,CAAC,KAAK,CAAC;iBACrC,aAAa,CAAC,CAAE,sCAAS,CAAC,eAAe,EAAE,oCAAO,CAAC,UAAU,CAAE,EAAE,iBAAiB,CAAC,MAAM,CAAC;iBAC1F,cAAc,CAAC,CAAE,sCAAS,CAAC,eAAe,EAAE,oCAAO,CAAC,UAAU,EAAE,oCAAO,CAAC,UAAU,CAAE,EAAE,iBAAiB,CAAC,MAAM,CAAC;iBAC/G,OAAO,EAAE;SACb,CAAC,CAAC;IACL,CAAC;IAED,sDAAsD;IACtD,+CAA+C;IACvC,MAAM,CAAC,OAAO,CAAC,IAAY,EAAE,OAAe,EAAE,KAAc;QAClE,2DAA2D;QAC3D,mDAAmD;QACnD,MAAM,GAAG,GAAG,IAAI,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACvC,OAAO,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACxB,CAAC;IAEO,MAAM,CAAC,MAAM;QACnB,OAAO,CAAC,IAAY,EAAE,OAAe,EAAE,EAAE,CAAC,IAAA,iCAAI,EAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,CAAC;IAC3F,CAAC;IAEO,MAAM,CAAC,MAAM;QACnB,OAAO,CAAC,IAAY,EAAE,OAAe,EAAE,KAAa,EAAE,EAAE,CAAC,IAAA,iCAAI,EAAC,iBAAiB,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;IACjH,CAAC;CACF;AA5BD,8CA4BC","sourcesContent":["import { TermFunctionBase } from '@comunica/bus-function-factory';\nimport type {\n  BooleanLiteral,\n} from '@comunica/utils-expression-evaluator';\nimport {\n  bool,\n  declare,\n  SparqlOperator,\n  TypeAlias,\n  TypeURL,\n} from '@comunica/utils-expression-evaluator';\n\n/**\n * https://www.w3.org/TR/sparql11-query/#func-regex\n */\nexport class TermFunctionRegex extends TermFunctionBase {\n  public constructor() {\n    super({\n      arity: [ 2, 3 ],\n      operator: SparqlOperator.REGEX,\n      overloads: declare(SparqlOperator.REGEX)\n        .onBinaryTyped([ TypeAlias.SPARQL_STRINGLY, TypeURL.XSD_STRING ], TermFunctionRegex.regex2)\n        .onTernaryTyped([ TypeAlias.SPARQL_STRINGLY, TypeURL.XSD_STRING, TypeURL.XSD_STRING ], TermFunctionRegex.regex3)\n        .collect(),\n    });\n  }\n\n  // https://www.w3.org/TR/xpath-functions/#func-matches\n  // https://www.w3.org/TR/xpath-functions/#flags\n  private static matches(text: string, pattern: string, flags?: string): boolean {\n    // TODO: Only flags 'i' and 'm' match between XPath and JS.\n    // 's', 'x', 'q', would need proper implementation.\n    const reg = new RegExp(pattern, flags);\n    return reg.test(text);\n  }\n\n  private static regex2(): (text: string, pattern: string) => BooleanLiteral {\n    return (text: string, pattern: string) => bool(TermFunctionRegex.matches(text, pattern));\n  }\n\n  private static regex3(): (text: string, pattern: string, flags: string) => BooleanLiteral {\n    return (text: string, pattern: string, flags: string) => bool(TermFunctionRegex.matches(text, pattern, flags));\n  }\n}\n"]}