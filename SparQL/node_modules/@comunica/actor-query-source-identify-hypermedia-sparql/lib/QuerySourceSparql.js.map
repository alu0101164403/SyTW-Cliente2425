{"version":3,"file":"QuerySourceSparql.js","sourceRoot":"","sources":["QuerySourceSparql.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorHttp } from '@comunica/bus-http';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport { Actor } from '@comunica/core';\nimport type {\n  Bindings,\n  BindingsStream,\n  ComunicaDataFactory,\n  FragmentSelectorShape,\n  IActionContext,\n  IQueryBindingsOptions,\n  IQuerySource,\n  MetadataBindings,\n  MetadataVariable,\n} from '@comunica/types';\nimport type { BindingsFactory } from '@comunica/utils-bindings-factory';\nimport { MetadataValidationState } from '@comunica/utils-metadata';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator, wrap } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport { LRUCache } from 'lru-cache';\nimport { uniqTerms } from 'rdf-terms';\nimport type { Factory, Algebra } from 'sparqlalgebrajs';\nimport { toSparql, Util } from 'sparqlalgebrajs';\nimport type { BindMethod } from './ActorQuerySourceIdentifyHypermediaSparql';\n\nconst COUNT_INFINITY: RDF.QueryResultCardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };\n\nexport class QuerySourceSparql implements IQuerySource {\n  protected static readonly SELECTOR_SHAPE: FragmentSelectorShape = {\n    type: 'disjunction',\n    children: [\n      {\n        type: 'operation',\n        operation: { operationType: 'wildcard' },\n        joinBindings: true,\n      },\n    ],\n  };\n\n  public readonly referenceValue: string;\n  private readonly url: string;\n  private readonly context: IActionContext;\n  private readonly mediatorHttp: MediatorHttp;\n  private readonly bindMethod: BindMethod;\n  private readonly countTimeout: number;\n  private readonly dataFactory: ComunicaDataFactory;\n  private readonly algebraFactory: Factory;\n  private readonly bindingsFactory: BindingsFactory;\n\n  private readonly endpointFetcher: SparqlEndpointFetcher;\n  private readonly cache: LRUCache<string, RDF.QueryResultCardinality> | undefined;\n\n  private lastSourceContext: IActionContext | undefined;\n\n  public constructor(\n    url: string,\n    context: IActionContext,\n    mediatorHttp: MediatorHttp,\n    bindMethod: BindMethod,\n    dataFactory: ComunicaDataFactory,\n    algebraFactory: Factory,\n    bindingsFactory: BindingsFactory,\n    forceHttpGet: boolean,\n    cacheSize: number,\n    countTimeout: number,\n  ) {\n    this.referenceValue = url;\n    this.url = url;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.bindMethod = bindMethod;\n    this.dataFactory = dataFactory;\n    this.algebraFactory = algebraFactory;\n    this.bindingsFactory = bindingsFactory;\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.lastSourceContext! },\n      ),\n      prefixVariableQuestionMark: true,\n      dataFactory,\n    });\n    this.cache = cacheSize > 0 ?\n      new LRUCache<string, RDF.QueryResultCardinality>({ max: cacheSize }) :\n      undefined;\n    this.countTimeout = countTimeout;\n  }\n\n  public async getSelectorShape(): Promise<FragmentSelectorShape> {\n    return QuerySourceSparql.SELECTOR_SHAPE;\n  }\n\n  public queryBindings(\n    operationIn: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ): BindingsStream {\n    // If bindings are passed, modify the operations\n    let operationPromise: Promise<Algebra.Operation>;\n    if (options?.joinBindings) {\n      operationPromise = QuerySourceSparql.addBindingsToOperation(\n        this.algebraFactory,\n        this.bindMethod,\n        operationIn,\n        options.joinBindings,\n      );\n    } else {\n      operationPromise = Promise.resolve(operationIn);\n    }\n\n    const bindings: BindingsStream = new TransformIterator(async() => {\n      // Prepare queries\n      const operation = await operationPromise;\n      const variables: RDF.Variable[] = Util.inScopeVariables(operation);\n      const queryString = context.get<string>(KeysInitQuery.queryString);\n      const selectQuery: string = !options?.joinBindings && queryString ?\n        queryString :\n        QuerySourceSparql.operationToSelectQuery(this.algebraFactory, operation, variables);\n      const undefVariables = QuerySourceSparql.getOperationUndefs(operation);\n\n      return this.queryBindingsRemote(this.url, selectQuery, variables, context, undefVariables);\n    }, { autoStart: false });\n    this.attachMetadata(bindings, context, operationPromise);\n\n    return bindings;\n  }\n\n  public queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad> {\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = this.endpointFetcher.fetchTriples(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    const quads = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });\n    this.attachMetadata(quads, context, Promise.resolve(operation.input));\n    return quads;\n  }\n\n  public queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchAsk(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  public queryVoid(operation: Algebra.Update, context: IActionContext): Promise<void> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchUpdate(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  protected attachMetadata(\n    target: AsyncIterator<any>,\n    context: IActionContext,\n    operationPromise: Promise<Algebra.Operation>,\n  ): void {\n    // Emit metadata containing the estimated count\n    let variablesCount: MetadataVariable[] = [];\n    // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises\n    new Promise<RDF.QueryResultCardinality>(async(resolve, reject) => {\n      // Prepare queries\n      let countQuery: string;\n      try {\n        const operation = await operationPromise;\n        const variablesScoped = Util.inScopeVariables(operation);\n        countQuery = QuerySourceSparql.operationToCountQuery(this.dataFactory, this.algebraFactory, operation);\n        const undefVariables = QuerySourceSparql.getOperationUndefs(operation);\n        variablesCount = variablesScoped.map(variable => ({\n          variable,\n          canBeUndef: undefVariables.some(undefVariable => undefVariable.equals(variable)),\n        }));\n\n        const cachedCardinality = this.cache?.get(countQuery);\n        if (cachedCardinality !== undefined) {\n          return resolve(cachedCardinality);\n        }\n\n        const timeoutHandler = setTimeout(() => resolve(COUNT_INFINITY), this.countTimeout);\n        const varCount = this.dataFactory.variable('count');\n        const bindingsStream: BindingsStream = await this\n          .queryBindingsRemote(this.url, countQuery, [ varCount ], context, []);\n        bindingsStream.on('data', (bindings: Bindings) => {\n          clearTimeout(timeoutHandler);\n          const count = bindings.get(varCount);\n          const cardinality: RDF.QueryResultCardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };\n          if (count) {\n            const cardinalityValue: number = Number.parseInt(count.value, 10);\n            if (!Number.isNaN(cardinalityValue)) {\n              cardinality.type = 'exact';\n              cardinality.value = cardinalityValue;\n              this.cache?.set(countQuery, cardinality);\n            }\n          }\n          return resolve(cardinality);\n        });\n        bindingsStream.on('error', () => {\n          clearTimeout(timeoutHandler);\n          resolve(COUNT_INFINITY);\n        });\n        bindingsStream.on('end', () => {\n          clearTimeout(timeoutHandler);\n          resolve(COUNT_INFINITY);\n        });\n      } catch (error: unknown) {\n        return reject(error);\n      }\n    })\n      .then((cardinality) => {\n        target.setProperty('metadata', {\n          state: new MetadataValidationState(),\n          cardinality,\n          variables: variablesCount,\n        });\n      })\n      .catch(() => target.setProperty('metadata', {\n        state: new MetadataValidationState(),\n        cardinality: COUNT_INFINITY,\n        variables: variablesCount,\n      }));\n  }\n\n  /**\n   * Create an operation that includes the bindings from the given bindings stream.\n   * @param algebraFactory The algebra factory.\n   * @param bindMethod A method for adding bindings to an operation.\n   * @param operation The operation to bind to.\n   * @param addBindings The bindings to add.\n   * @param addBindings.bindings The bindings stream.\n   * @param addBindings.metadata The bindings metadata.\n   */\n  public static async addBindingsToOperation(\n    algebraFactory: Factory,\n    bindMethod: BindMethod,\n    operation: Algebra.Operation,\n    addBindings: { bindings: BindingsStream; metadata: MetadataBindings },\n  ): Promise<Algebra.Operation> {\n    const bindings = await addBindings.bindings.toArray();\n\n    switch (bindMethod) {\n      case 'values':\n        return algebraFactory.createJoin([\n          algebraFactory.createValues(\n            addBindings.metadata.variables.map(v => v.variable),\n            bindings.map(binding => Object.fromEntries([ ...binding ]\n              .map(([ key, value ]) => [ `?${key.value}`, <RDF.Literal | RDF.NamedNode> value ]))),\n          ),\n          operation,\n        ], false);\n      case 'union': { throw new Error('Not implemented yet: \"union\" case'); }\n      case 'filter': { throw new Error('Not implemented yet: \"filter\" case'); }\n    }\n  }\n\n  /**\n   * Convert an operation to a select query for this pattern.\n   * @param algebraFactory The algebra factory.\n   * @param {Algebra.Operation} operation A query operation.\n   * @param {RDF.Variable[]} variables The variables in scope for the operation.\n   * @return {string} A select query string.\n   */\n  public static operationToSelectQuery(\n    algebraFactory: Factory,\n    operation: Algebra.Operation,\n    variables: RDF.Variable[],\n  ): string {\n    return QuerySourceSparql.operationToQuery(algebraFactory.createProject(operation, variables));\n  }\n\n  /**\n   * Convert an operation to a count query for the number of matching triples for this pattern.\n   * @param dataFactory The data factory.\n   * @param algebraFactory The algebra factory.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A count query string.\n   */\n  public static operationToCountQuery(\n    dataFactory: ComunicaDataFactory,\n    algebraFactory: Factory,\n    operation: Algebra.Operation,\n  ): string {\n    return QuerySourceSparql.operationToQuery(algebraFactory.createProject(\n      algebraFactory.createExtend(\n        algebraFactory.createGroup(\n          operation,\n          [],\n          [ algebraFactory.createBoundAggregate(\n            dataFactory.variable('var0'),\n            'count',\n            algebraFactory.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        dataFactory.variable('count'),\n        algebraFactory.createTermExpression(dataFactory.variable('var0')),\n      ),\n      [ dataFactory.variable('count') ],\n    ));\n  }\n\n  /**\n   * Convert an operation to a query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A query string.\n   */\n  public static operationToQuery(operation: Algebra.Operation): string {\n    return toSparql(operation, { sparqlStar: true });\n  }\n\n  /**\n   * Check if the given operation may produce undefined values.\n   * @param operation\n   */\n  public static getOperationUndefs(operation: Algebra.Operation): RDF.Variable[] {\n    const variables: RDF.Variable[] = [];\n    Util.recurseOperation(operation, {\n      leftjoin(subOperation): boolean {\n        const left = Util.inScopeVariables(subOperation.input[0]);\n        const right = Util.inScopeVariables(subOperation.input[1]);\n        for (const varRight of right) {\n          if (!left.some(varLeft => varLeft.equals(varRight))) {\n            variables.push(varRight);\n          }\n        }\n        return false;\n      },\n      values(values: Algebra.Values): boolean {\n        for (const variable of values.variables) {\n          if (values.bindings.some(bindings => !(`?${variable.value}` in bindings))) {\n            variables.push(variable);\n          }\n        }\n        return false;\n      },\n      union(union: Algebra.Union): boolean {\n        // Determine variables in scope of the union branches that are not occurring in every branch\n        const scopedVariables = union.input.map(Util.inScopeVariables);\n        for (const variable of uniqTerms(scopedVariables.flat())) {\n          if (!scopedVariables.every(input => input.some(inputVar => inputVar.equals(variable)))) {\n            variables.push(variable);\n          }\n        }\n\n        return true;\n      },\n    });\n    return uniqTerms(variables);\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @param {RDF.Variable[]} variables The expected variables.\n   * @param {IActionContext} context The source context.\n   * @param undefVariables Variables that may have undefs.\n   * @return {BindingsStream} A stream of bindings.\n   */\n  public async queryBindingsRemote(\n    endpoint: string,\n    query: string,\n    variables: RDF.Variable[],\n    context: IActionContext,\n    undefVariables: RDF.Variable[],\n  ): Promise<BindingsStream> {\n    // Index undef variables\n    const undefVariablesIndex: Set<string> = new Set();\n    for (const undefVariable of undefVariables) {\n      undefVariablesIndex.add(undefVariable.value);\n    }\n\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = await this.endpointFetcher.fetchBindings(endpoint, query);\n    this.lastSourceContext = undefined;\n\n    return wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n      .map<RDF.Bindings>((rawData: Record<string, RDF.Term>) => this.bindingsFactory.bindings(variables\n        .map((variable) => {\n          const value = rawData[`?${variable.value}`];\n          if (!undefVariablesIndex.has(variable.value) && !value) {\n            Actor.getContextLogger(this.context)?.warn(`The endpoint ${endpoint} failed to provide a binding for ${variable.value}.`);\n          }\n          return <[RDF.Variable, RDF.Term]>[ variable, value ];\n        })\n        .filter(([ _, v ]) => Boolean(v))));\n  }\n\n  public toString(): string {\n    return `QuerySourceSparql(${this.url})`;\n  }\n}\n"]}